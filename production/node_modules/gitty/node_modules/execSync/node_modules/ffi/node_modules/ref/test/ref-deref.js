var assert=null,ref=null;describe("ref(), deref()",function(){beforeEach(gc),it("should work 1 layer deep",function(){var e=new Buffer("one layer deep"),r=ref.ref(e),f=ref.deref(r);assert.equal(e.length,f.length),assert.equal(""+e,""+f)}),it("should work 2 layers deep",function(){var e=new Buffer("two layers deep"),r=ref.ref(e),f=ref.ref(r),s=ref.deref(f),t=ref.deref(s);assert.equal(ref.address(r),ref.address(s)),assert.equal(ref.address(e),ref.address(t)),assert.equal(r.length,s.length),assert.equal(e.length,t.length),assert.equal(""+e,""+t)}),it('should throw when derefing a Buffer with no "type"',function(){var e=new Buffer("???");assert.throws(function(){ref.deref(e)},/unknown "type"/)}),it('should throw when derefing a Buffer with no "type" 2',function(){var e=new Buffer("???"),r=ref.ref(e),f=ref.deref(r);assert.equal(ref.address(e),ref.address(f)),assert.throws(function(){ref.deref(f)},/unknown "type"/)}),it('should deref() a "char" type properly',function(){var e=new Buffer(ref.sizeof.char);e.type=ref.types.char,e[0]=50,assert.equal(50,ref.deref(e)),e[0]=127,assert.equal(127,ref.deref(e))}),it("should not throw when calling ref()/deref() on a `void` type",function(){var e=ref.alloc(ref.types.void);assert.strictEqual(null,e.deref())})});