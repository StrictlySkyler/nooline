var assert=null,ref=null;describe("types",function(){describe("refType()",function(){it('should return a new "type" with its `indirection` level increased by 1',function(){var e=ref.types.int,i=ref.refType(e);assert.equal(e.size,i.size),assert.equal(e.indirection+1,i.indirection)}),it("should coerce string types",function(){var e=ref.refType("int");assert.equal(2,e.indirection),assert.equal(e.size,ref.types.int.size)})}),describe("derefType()",function(){it('should return a new "type" with its `indirection` level decreased by 1',function(){var e,i=Object.create(ref.types.int);i.indirection++,e=ref.derefType(i),assert.equal(i.size,i.size),assert.equal(i.indirection-1,e.indirection)}),it('should throw an Error when given a "type" with its `indirection` level already at 1',function(){assert.throws(function(){ref.derefType(ref.types.int)})})}),describe("size",function(){Object.keys(ref.types).forEach(function(e){"void"!==e&&it("sizeof("+e+") should be >= 1",function(){var i=ref.types[e];assert.equal("number",typeof i.size),assert(i.size>=1)})})}),describe("alignment",function(){Object.keys(ref.types).forEach(function(e){"void"!==e&&it("alignof("+e+") should be >= 1",function(){var i=ref.types[e];assert.equal("number",typeof i.alignment),assert(i.alignment>=1)})})})});