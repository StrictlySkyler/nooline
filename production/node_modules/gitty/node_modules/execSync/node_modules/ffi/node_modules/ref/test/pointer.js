var assert=null,weak=null,ref=null;describe("pointer",function(){var e=new Buffer("hello world");beforeEach(gc),it("should write and read back a pointer (Buffer) in a Buffer",function(){var r,t,o,n=new Buffer(ref.sizeof.pointer);for(ref.writePointer(n,0,e),r=ref.readPointer(n,0,e.length),assert.strictEqual(r.length,e.length),t=0,o=r.length;o>t;t++)assert.strictEqual(r[t],e[t]);assert.strictEqual(ref.address(r),ref.address(e))}),it("should retain references to a written pointer in a Buffer",function(){var e=!1,r=!1,t=new Buffer("a pointer holding some data..."),o=new Buffer(ref.sizeof.pointer);weak(t,function(){e=!0}),weak(o,function(){r=!0}),ref.writePointer(o,0,t),assert(!e,'"child" has been garbage collected too soon'),assert(!r,'"parent" has been garbage collected too soon'),t=null,gc(),assert(!e,'"child" has been garbage collected too soon'),assert(!r,'"parent" has been garbage collected too soon'),o=null,gc(),assert(r,'"parent" has not been garbage collected'),assert(e,'"child" has not been garbage collected')}),it("should throw an Error when reading from the NULL pointer",function(){assert.throws(function(){ref.NULL.readPointer()})}),describe("offset",function(){it("should read two pointers next to each other in memory",function(){var e,r,t=new Buffer(2*ref.sizeof.pointer),o=new Buffer("hello"),n=new Buffer("world");t.writePointer(o,0*ref.sizeof.pointer),t.writePointer(n,1*ref.sizeof.pointer),e=t.readPointer(0*ref.sizeof.pointer),r=t.readPointer(1*ref.sizeof.pointer),assert.equal(o.address(),e.address()),assert.equal(n.address(),r.address())})})});