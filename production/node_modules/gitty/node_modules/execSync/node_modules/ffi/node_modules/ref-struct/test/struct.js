var assert=null,ref=null,ArrayType=null,Struct=null,bindings=null;describe("Struct",function(){afterEach(gc),it("should be a function",function(){assert.equal("function",typeof Struct)}),it("should return a struct constuctor function",function(){var e=Struct();assert.equal("function",typeof e)}),it("should throw when the same field name is speicified more than once",function(){var e=Struct({a:ref.types.int});assert.throws(function(){e.defineProperty("a",ref.types.int)})}),it('should throw when given a type with "size" == 0',function(){assert.throws(function(){Struct({v:"void"})})}),it("should work in a simple case",function(){var e,t=Struct({first:ref.types.byte,last:ref.types.byte});assert.equal(2,t.size),assert.equal(1,t.alignment),e=new t({first:50,last:100}),assert.equal(50,e.first),assert.equal(100,e.last)}),it("should work in a more complex case",function(){var e=Struct({byteVal:ref.types.byte,int8Val:ref.types.int8,int16Val:ref.types.int16,uint16Val:ref.types.uint16,int32Val:ref.types.int32,uint32Val:ref.types.uint32,floatVal:ref.types.float,doubleVal:ref.types.double,pointer:ref.refType("void")}),t=new Buffer(1),r=new e({byteVal:100,int8Val:-100,int16Val:-1e3,uint16Val:1e3,int32Val:-1e4,uint32Val:1e4,floatVal:1.25,doubleVal:1000.0005,pointerVal:t});assert.equal(100,r.byteVal),assert.equal(-100,r.int8Val),assert.equal(-1e3,r.int16Val),assert.equal(1e3,r.uint16Val),assert.equal(-1e4,r.int32Val),assert.equal(1e4,r.uint32Val),assert.equal(1.25,r.floatVal),assert.equal(1000.0005,r.doubleVal),assert.equal(r.pointerVal.address(),t.address())}),it("should allow Struct nesting",function(){var e=Struct({a:ref.types.int,b:ref.types.int}),t=Struct({childA:e,childB:e}),r=new t({childA:{a:100,b:200},childB:{a:300,b:400}});assert.equal(100,r.childA.a),assert.equal(200,r.childA.b),assert.equal(300,r.childB.a),assert.equal(400,r.childB.b)}),describe("string type identifiers",function(){it("should work with string type identifiers",function(){var e=Struct({"int":"int","long":"long",string:"string"});assert.strictEqual(ref.types.int,e.fields.int.type),assert.strictEqual(ref.types.long,e.fields.long.type),assert.strictEqual(ref.types.CString,e.fields.string.type)}),it('should work as expected with "void *" as a type',function(){var e=Struct({ptr1:"void *",ptr2:"void *"}),t=new e,r=new Buffer(1);t.ptr1=ref.NULL,t.ptr2=r,assert.equal(ref.NULL.address(),t.ptr1.address()),assert.equal(r.address(),t.ptr2.address())})}),describe("ref(), deref()",function(){it("should work to ref() and then deref() 1 level deep",function(){var e,t=Struct({d:"double"}),r=new t({d:Math.PI}),a=r.ref();assert(Buffer.isBuffer(a)),e=a.deref(),assert(e instanceof t),assert.equal(Math.PI,e.d)})}),describe("offsets and sizeofs",function(){function e(e,t){describe("Struct test"+t,function(){it("should have its `size` matching sizeof()",function(){var r=bindings["test"+t+" sizeof"];assert.equal(r,e.size,"test"+t+": sizeof(): expected "+e.size+" to equal "+r)}),it("should have its `alignment` matching __alignof__()",function(){var r=bindings["test"+t+" alignof"];assert.equal(r,e.alignment,"test"+t+": __alignof__(): expected "+e.alignment+" to equal "+r)}),Object.keys(e.fields).forEach(function(r){it('should have a matching offsetof() for "'+r+'"',function(){var a=bindings["test"+t+" offsetof "+r],s=e.fields[r].offset;assert.equal(a,s,"test"+t+": offsetof("+r+"): expected "+s+" to equal "+a)})})})}var t,r,a,s,i,n,f,o,u,l,c,y,p,d,h,b,S,q,g,v,P=Struct({a:ref.types.int,b:ref.types.int,c:ref.types.double});e(P,1),t=Struct({a:ref.types.int,b:ref.types.double,c:ref.types.int}),e(t,2),r=Struct({a:ref.types.double,b:ref.types.int,c:ref.types.int}),e(r,3),a=Struct({a:ref.types.double,b:ref.types.double,c:ref.types.int}),e(a,4),s=Struct({a:ref.types.int,b:ref.types.double,c:ref.types.double}),e(s,5),i=Struct({a:ref.types.char,b:ref.types.short,c:ref.types.int}),e(i,6),n=Struct({a:ref.types.int,b:ref.types.short,c:ref.types.char}),e(n,7),f=Struct({a:ref.types.int,b:ref.types.short,c:ref.types.char,d:ref.types.char}),e(f,8),o=Struct({a:ref.types.int,b:ref.types.short,c:ref.types.char,d:ref.types.char,e:ref.types.char}),e(o,9),u=Struct({a:P,b:ref.types.char}),e(u,10),l=Struct(),l.defineProperty("a",ref.types.size_t),l.defineProperty("b",ref.types.ushort),l.defineProperty("c",ref.types.ushort),c=ref.refType(ref.refType(l)),l.defineProperty("d",c),e(l,11),y=Struct({a:ref.refType(ref.types.char),b:ref.types.int}),e(y,12),p=Struct({a:ref.types.char,b:ArrayType("char",2)}),e(p,13),d=Struct({a:ref.types.char,b:ArrayType("char",2),c:ref.types.short,d:ref.types.char}),e(d,14),h=Struct({a:P,b:P}),e(h,15),b=Struct({a:ArrayType("double",10),b:ArrayType("char",3),c:ArrayType("int",6)}),e(b,16),S=Struct({a:ArrayType("char",3)}),e(S,17),q=Struct({a:ArrayType(S,100)}),e(q,18),g=256,v=Struct(),v.defineProperty("has_meta_data","bool"),v.defineProperty("playable","bool"),v.defineProperty("geo_restricted","bool"),v.defineProperty("track_id",ArrayType("uchar",33)),v.defineProperty("file_id",ArrayType("uchar",41)),v.defineProperty("file_bitrate","uint"),v.defineProperty("album_id",ArrayType("uchar",33)),v.defineProperty("cover_id",ArrayType("uchar",41)),v.defineProperty("key","uchar *"),v.defineProperty("allowed","char *"),v.defineProperty("forbidden","char *"),v.defineProperty("title",ArrayType("char",g)),v.defineProperty("artist","void *"),v.defineProperty("album",ArrayType("char",g)),v.defineProperty("length","int"),v.defineProperty("tracknumber","int"),v.defineProperty("year","int"),v.defineProperty("popularity","float"),v.defineProperty("next",ref.refType(v)),e(v,19)})});