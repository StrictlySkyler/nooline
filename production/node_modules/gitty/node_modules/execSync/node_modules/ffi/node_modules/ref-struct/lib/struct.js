function Struct(){function e(t,n){var i,r;if(!(this instanceof e))return new e(t,n);if(debug("creating new struct instance"),Buffer.isBuffer(t)?(debug("using passed-in Buffer instance to back the struct",t),assert(t.length>=e.size,"Buffer instance must be at least "+e.size+" bytes to back this struct type"),i=t,t=n):(debug("creating new Buffer instance to back the struct (size: %d)",e.size),i=new Buffer(e.size)),i.type=e,this["ref.buffer"]=i,t)for(r in t)this[r]=t[r];e._instanceCreated=!0}debug('defining new struct "type"'),e.prototype=Object.create(proto,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),e.defineProperty=defineProperty,e.toString=toString,e.fields={},e.size=0,e.alignment=0,e.indirection=1,e.get=get,e.set=set;var t=arguments[0];return Array.isArray(t)?t.forEach(function(t){var n=t[0],i=t[1];e.defineProperty(i,n)}):"object"==typeof t&&Object.keys(t).forEach(function(n){var i=t[n];e.defineProperty(n,i)}),e}function get(e,t){return debug('Struct "type" getter for buffer at offset',e,t),t>0&&(e=e.slice(t)),new this(e)}function set(e,t,n){debug('Struct "type" setter for buffer at offset',e,t,n),t>0&&(e=e.slice(t));var i=n instanceof this;i?n["ref.buffer"].copy(e,t,0,this.size):new this(e,n)}function toString(){return"[StructType]"}function defineProperty(e,t){var n,i;debug("defining new struct type field",e),t=ref.coerceType(t),assert(!this._instanceCreated,'an instance of this Struct type has already been created, cannot add new "fields" anymore'),assert.equal("string",typeof e,'expected a "string" field name'),assert(t&&/object|function/i.test(typeof t)&&"size"in t&&"indirection"in t,'expected a "type" object describing the field type: "'+t+'"'),assert(t.indirection>1||t.size>0,'"type" object must have a size greater than 0'),assert(!(e in this.prototype),'the field "'+e+'" already exists in this Struct type'),n={type:t},this.fields[e]=n,i={enumerable:!0,configurable:!0},i.get=function(){return debug('getting "%s" struct field (offset: %d)',e,n.offset),ref.get(this["ref.buffer"],n.offset,t)},i.set=function(i){return debug('setting "%s" struct field (offset: %d)',e,n.offset,i),ref.set(this["ref.buffer"],n.offset,i,t)},recalc(this),Object.defineProperty(this.prototype,e,i)}function recalc(e){function t(t){var n=e.size,i=1===t.indirection?t.alignment:ref.alignof.pointer,r=(i-n%i)%i,f=1===t.indirection?t.size:ref.sizeof.pointer;return n+=r,assert.equal(n%i,0,"offset should align"),e.size=n+f,n}var n,i;e.size=0,e.alignment=0,n=Object.keys(e.fields),n.forEach(function(t){var n=e.fields[t],i=n.type,r=i.alignment||ref.alignof.pointer;i.indirection>1&&(r=ref.alignof.pointer),e.alignment=Math.max(e.alignment,r)}),n.forEach(function(n){var i,r=e.fields[n],f=r.type;if(null!=f.fixedLength)for(r.offset=t(f.type),i=1;i<f.fixedLength;i++)t(f.type);else r.offset=t(f)}),i=e.size%e.alignment,i>0&&(debug("additional padding to the end of struct:",e.alignment-i),e.size+=e.alignment-i)}var proto,ref=null,util=null,assert=null,debug=null;module.exports=Struct,proto={},proto["ref.buffer"]=ref.NULL,proto.toObject=function(){var e={};return Object.keys(this.constructor.fields).forEach(function(t){e[t]=this[t]},this),e},proto.toJSON=function(){return this.toObject()},proto.inspect=function(){var e=this.toObject();return Object.keys(this).forEach(function(t){e[t]=this[t]},this),util.inspect(e)},proto.ref=function(){return this["ref.buffer"]};