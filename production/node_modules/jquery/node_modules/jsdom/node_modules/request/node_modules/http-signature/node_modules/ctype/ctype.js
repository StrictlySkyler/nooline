function ctReadUint8(t,r,e){var i=mod_ctio.ruint8(r,t,e);return{value:i,size:1}}function ctReadUint16(t,r,e){var i=mod_ctio.ruint16(r,t,e);return{value:i,size:2}}function ctReadUint32(t,r,e){var i=mod_ctio.ruint32(r,t,e);return{value:i,size:4}}function ctReadUint64(t,r,e){var i=mod_ctio.ruint64(r,t,e);return{value:i,size:8}}function ctReadSint8(t,r,e){var i=mod_ctio.rsint8(r,t,e);return{value:i,size:1}}function ctReadSint16(t,r,e){var i=mod_ctio.rsint16(r,t,e);return{value:i,size:2}}function ctReadSint32(t,r,e){var i=mod_ctio.rsint32(r,t,e);return{value:i,size:4}}function ctReadSint64(t,r,e){var i=mod_ctio.rsint64(r,t,e);return{value:i,size:8}}function ctReadFloat(t,r,e){var i=mod_ctio.rfloat(r,t,e);return{value:i,size:4}}function ctReadDouble(t,r,e){var i=mod_ctio.rdouble(r,t,e);return{value:i,size:8}}function ctReadChar(t,r,e){var i=new Buffer(1);return i[0]=mod_ctio.ruint8(r,t,e),{value:i,size:1}}function ctReadCharArray(t,r,e,i){var n,o=new Buffer(t);for(n=0;t>n;n++)o[n]=mod_ctio.ruint8(e,r,i+n);return{value:o,size:t}}function ctWriteUint8(t,r,e,i){return mod_ctio.wuint8(t,r,e,i),1}function ctWriteUint16(t,r,e,i){return mod_ctio.wuint16(t,r,e,i),2}function ctWriteUint32(t,r,e,i){return mod_ctio.wuint32(t,r,e,i),4}function ctWriteUint64(t,r,e,i){return mod_ctio.wuint64(t,r,e,i),8}function ctWriteSint8(t,r,e,i){return mod_ctio.wsint8(t,r,e,i),1}function ctWriteSint16(t,r,e,i){return mod_ctio.wsint16(t,r,e,i),2}function ctWriteSint32(t,r,e,i){return mod_ctio.wsint32(t,r,e,i),4}function ctWriteSint64(t,r,e,i){return mod_ctio.wsint64(t,r,e,i),8}function ctWriteFloat(t,r,e,i){return mod_ctio.wfloat(t,r,e,i),4}function ctWriteDouble(t,r,e,i){return mod_ctio.wdouble(t,r,e,i),8}function ctWriteChar(t,r,e,i){if(!(t instanceof Buffer))throw Error("Input must be a buffer");return mod_ctio.ruint8(t[0],r,e,i),1}function ctWriteCharArray(t,r,e,i,n){var o;if(!(t instanceof Buffer))throw Error("Input must be a buffer");if(t.length>r)throw Error("value length greater than array length");for(o=0;o<t.length&&r>o;o++)mod_ctio.wuint8(t[o],e,i,n+o);for(;r>o;o++)mod_ctio.wuint8(0,e,n+o);return r}function ctGetBasicTypes(){var t,r={};for(t in deftypes)r[t]=deftypes[t];return r}function ctParseType(t){var r,e,i,n;if("string"!=typeof t)throw Error("type must be a Javascript string");if(e=t.lastIndexOf("]"),-1==e){if(-1!=t.lastIndexOf("["))throw Error("found invalid type with '[' but no corresponding ']'");return{type:t}}if(r=t.lastIndexOf("["),-1==r)throw Error("found invalid type with ']' but no corresponding '['");if(r>=e)throw Error("malformed type, ']' appears before '['");return i=t.substring(0,r),n=t.substring(r+1,e),{type:i,len:n}}function ctCheckReq(t,r,e){var i,n,o,a,s,u={};if(!(t instanceof Array))throw Error("definition is not an array");if(0===t.length)throw Error("definition must have at least one element");for(i=0;i<t.length;i++){if(o=t[i],!(o instanceof Object))throw Error("definition must be an array ofobjects");if(a=Object.keys(o),1!=a.length)throw Error("definition entry must only have one key");if(a[0]in u)throw Error("Specified name already specified: "+a[0]);if(!("type"in o[a[0]]))throw Error("missing required type definition");for(s=ctParseType(o[a[0]].type);void 0!==s.len;){if(isNaN(parseInt(s.len,10))&&!(s.len in u))throw Error("Given an array length without a matching type");s=ctParseType(s.type)}if(!(s.type in r))throw Error("type not found or typdefed: "+s.type);if(void 0!==e)for(n=0;n<e.length;n++)if(!(e[n]in o[a[0]]))throw Error("Missing required field: "+e[n]);u[a[0]]=!0}}function CTypeParser(t){if(!t)throw Error("missing required argument");if(!("endian"in t))throw Error("missing required endian value");if("big"!=t.endian&&"little"!=t.endian)throw Error("Invalid endian type");if("char-type"in t&&"uint8"!=t["char-type"]&&"int8"!=t["char-type"])throw Error("invalid option for char-type: "+t["char-type"]);this.endian=t.endian,this.types=ctGetBasicTypes(),"char-type"in t&&"uint8"==t["char-type"]&&(this.types["char"]=this.types.uint8_t),"char-type"in t&&"int8"==t["char-type"]&&(this.types["char"]=this.types.int8_t)}function ctResolveArray(t,r){for(var e="",i=ctParseType(t);void 0!==i.len;){if(isNaN(parseInt(i.len,10))){if("number"!=typeof r[i.len])throw Error("cannot sawp in non-number for array value");e="["+r[i.len]+"]"+e}else e="["+i.len+"]"+e;i=ctParseType(i.type)}return e=i.type+e}function getValues(t){var r,e,i;for(e=[],r=0;r<t.length;r++)i=Object.keys(t[r])[0],mod_assert.ok("value"in t[r][i]),e.push(t[r][i].value);return e}function toAbs64(t){if(void 0===t)throw Error("missing required arg: value");if(!Array.isArray(t))throw Error("value must be an array");if(2!=t.length)throw Error("value must be an array of length 2");if(t[0]>=1048576)throw Error("value would become approximated");return t[0]*Math.pow(2,32)+t[1]}function toApprox64(t){if(void 0===t)throw Error("missing required arg: value");if(!Array.isArray(t))throw Error("value must be an array");if(2!=t.length)throw Error("value must be an array of length 2");return Math.pow(2,32)*t[0]+t[1]}function parseCTF(t,r){var e=new CTypeParser(r);return mod_ctf.ctfParseJson(t,e),e}var mod_ctf=null,mod_ctio=null,mod_assert=null,deftypes={uint8_t:{read:ctReadUint8,write:ctWriteUint8},uint16_t:{read:ctReadUint16,write:ctWriteUint16},uint32_t:{read:ctReadUint32,write:ctWriteUint32},uint64_t:{read:ctReadUint64,write:ctWriteUint64},int8_t:{read:ctReadSint8,write:ctWriteSint8},int16_t:{read:ctReadSint16,write:ctWriteSint16},int32_t:{read:ctReadSint32,write:ctWriteSint32},int64_t:{read:ctReadSint64,write:ctWriteSint64},"float":{read:ctReadFloat,write:ctWriteFloat},"double":{read:ctReadDouble,write:ctWriteDouble},"char":{read:ctReadChar,write:ctWriteChar},"char[]":{read:ctReadCharArray,write:ctWriteCharArray}};CTypeParser.prototype.setEndian=function(t){if("big"!=t&&"little"!=t)throw Error("invalid endian type, must be big or little");this.endian=t},CTypeParser.prototype.getEndian=function(){return this.endian},CTypeParser.prototype.typedef=function(t,r){var e;if(void 0===t)throw new(Error("missing required typedef argument: name"));if(void 0===r)throw new(Error("missing required typedef argument: value"));if("string"!=typeof t)throw new(Error("the name of a type must be a string"));if(e=ctParseType(t),void 0!==e.len)throw Error("Cannot have an array in the typedef name");if(t in this.types)throw Error("typedef name already present: "+t);if("string"!=typeof r&&!(r instanceof Array))throw Error("typedef value must either be a string or struct");if("string"==typeof r){if(e=ctParseType(r),void 0!==e.len&&isNaN(parseInt(e.len,10)))throw new(Error("typedef value must use fixed size array when outside of a struct"));this.types[t]=r}else ctCheckReq(r,this.types),this.types[t]=r},CTypeParser.prototype.lstypes=function(){var t,r={};for(t in this.types)t in deftypes||(r[t]=this.types[t]);return r},CTypeParser.prototype.resolveTypedef=function(t,r,e,i,n){var o;if(mod_assert.ok(t in this.types),"string"==typeof this.types[t]){if(o=ctParseType(this.types[t]),"read"==r)return this.readEntry(o,e,i);if("write"==r)return this.writeEntry(n,o,e,i);throw Error("invalid dispatch type to resolveTypedef")}if("read"==r)return this.readStruct(this.types[t],e,i);if("write"==r)return this.writeStruct(n,this.types[t],e,i);throw Error("invalid dispatch type to resolveTypedef")},CTypeParser.prototype.readEntry=function(t,r,e){var i,n;if(void 0!==t.len){if(n=parseInt(t.len,10),isNaN(n))throw Error("somehow got a non-numeric length");i="char"==t.type?this.types["char[]"].read(n,this.endian,r,e):this.readArray(t.type,n,r,e)}else i=t.type in deftypes?this.types[t.type].read(this.endian,r,e):this.resolveTypedef(t.type,"read",r,e);return i},CTypeParser.prototype.readArray=function(t,r,e,i){var n,o,a=i,s=Array(r),u=ctParseType(t);for(n=0;r>n;n++)o=this.readEntry(u,e,i),i+=o.size,s[n]=o.value;return{value:s,size:i-a}},CTypeParser.prototype.readStruct=function(t,r,e){var i,n,o,a,s,u=e,c={};for(n=0;n<t.length;n++)s=Object.keys(t[n])[0],a=t[n][s],o=ctParseType(ctResolveArray(a.type,c)),"offset"in a&&(e=u+a.offset),i=this.readEntry(o,r,e),e+=i.size,c[s]=i.value;return{value:c,size:e-u}},CTypeParser.prototype.readData=function(t,r,e){if(void 0===t)throw Error("missing definition for what we should beparsing");if(void 0===r)throw Error("missing buffer for what we should be parsing");if(void 0===e)throw Error("missing offset for what we should be parsing");return ctCheckReq(t,this.types),this.readStruct(t,r,e).value},CTypeParser.prototype.writeArray=function(t,r,e,i,n){var o,a,s=n;if(!(t instanceof Array))throw Error("asked to write an array, but value is not an array");if(t.length!=e)throw Error("asked to write array of length "+e+" but that does not match value length: "+t.length);for(a=ctParseType(r),o=0;e>o;o++)n+=this.writeEntry(t[o],a,i,n);return n-s},CTypeParser.prototype.writeEntry=function(t,r,e,i){var n,o;if(void 0!==r.len){if(n=parseInt(r.len,10),isNaN(n))throw Error("somehow got a non-numeric length");o="char"==r.type?this.types["char[]"].write(t,n,this.endian,e,i):this.writeArray(t,r.type,n,e,i)}else o=r.type in deftypes?this.types[r.type].write(t,this.endian,e,i):this.resolveTypedef(r.type,"write",e,i,t);return o},CTypeParser.prototype.writeStruct=function(t,r,e,i){var n,o,a,s,u=i,c={};for(n=0;n<r.length;n++)s=Object.keys(r[n])[0],o=r[n][s],a=ctParseType(ctResolveArray(o.type,c)),"offset"in o&&(i=u+o.offset),i+=this.writeEntry(t[n],a,e,i),c[s]=t[n];return i},CTypeParser.prototype.writeData=function(t,r,e,i){var n;if(void 0===t)throw Error("missing definition for what we should beparsing");if(void 0===r)throw Error("missing buffer for what we should be parsing");if(void 0===e)throw Error("missing offset for what we should be parsing");if(n=null!=i&&void 0!=i){if(!Array.isArray(i))throw Error("missing values for writing");ctCheckReq(t,this.types)}else ctCheckReq(t,this.types,["value"]);this.writeStruct(n?i:getValues(t),t,r,e)},exports.Parser=CTypeParser,exports.toAbs64=toAbs64,exports.toApprox64=toApprox64,exports.parseCTF=parseCTF,exports.ruint8=mod_ctio.ruint8,exports.ruint16=mod_ctio.ruint16,exports.ruint32=mod_ctio.ruint32,exports.ruint64=mod_ctio.ruint64,exports.wuint8=mod_ctio.wuint8,exports.wuint16=mod_ctio.wuint16,exports.wuint32=mod_ctio.wuint32,exports.wuint64=mod_ctio.wuint64,exports.rsint8=mod_ctio.rsint8,exports.rsint16=mod_ctio.rsint16,exports.rsint32=mod_ctio.rsint32,exports.rsint64=mod_ctio.rsint64,exports.wsint8=mod_ctio.wsint8,exports.wsint16=mod_ctio.wsint16,exports.wsint32=mod_ctio.wsint32,exports.wsint64=mod_ctio.wsint64,exports.rfloat=mod_ctio.rfloat,exports.rdouble=mod_ctio.rdouble,exports.wfloat=mod_ctio.wfloat,exports.wdouble=mod_ctio.wdouble;